# -*- coding: utf-8 -*-
"""Cost_of_intepretability_blocked_value_iteration_2D_Splits_and_experiment_code

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qy47sNw577Nl6gwrHY8EnP_9_w5Vcl57
"""

import numpy as np
import matplotlib.pyplot as plt
from itertools import product
from collections import namedtuple
import matplotlib.markers as mrk
import math
import random


random.seed(10)
np.random.seed(100)

random.seed(10)
np.random.seed(100)
Data = namedtuple('data', ['x', 'y'])

class GridData:

    def __init__(self, sizes,
                 number_of_points_per_dimension = [],
                 goals=[], noise = 0.0, obstacles = []):

        '''
        A class that defines the grid data

        Parameters:
        ---------------------------------
        sizes: np.array[d]
              The sizes of the grid in the various dimensions

        number_of_points_per_dimension: np.array[d]
                                        The number of points per dimension

        goals: list[np.array[d]]
               Positions of the goals of the various points

        noise: float
               Final policy would follow the predicted output with prob 1 - noise
               and take a random action with probability = noise

        obstacles: list[np.array[d]]
                   The positions of the obstacles on the grid
        '''

        self.sizes = sizes
        self.number_of_points_per_dimension = number_of_points_per_dimension
        if len(self.number_of_points_per_dimension) == 0:
            self.number_of_points_per_dimension = self.sizes
        if len(goals) == 0:
            self.goals = goals
        self.noise = noise
        self.obstacles = obstacles


    @staticmethod
    def check_parallel_and_scaling(x, y):
        # Check if the arrays have the same shape
        if x.shape != y.shape:
            raise ValueError("Arrays must have the same shape")

        # Calculate the dot product of the flattened arrays
        dot_product = np.dot(x.flatten(), y.flatten())

        # Calculate the norms of the arrays
        norm_x = np.linalg.norm(x)
        norm_y = np.linalg.norm(y)

        # Check if the arrays are parallel (dot product should be proportional to norms)
        if np.isclose(dot_product, norm_x * norm_y):
            # Calculate the scaling factor
            scaling_factor = norm_y / norm_x
            return (True, scaling_factor)
        else:
            return (False, None)


    @staticmethod
    def is_point_on_line_segment(point, start, end):
        # Check if the point lies within the bounding box of the line segment
        dimension = len(start)

        for d in range(dimension):
            if (min(start[d], end[d]) > point[d]) or (point[d] > max(start[d], end[d])):
                print(f'Point {point} is not on the line connecting {start} and {end}')
                return False

        cross_product = np.cross(point - start, end - start)

        if np.isclose(cross_product, 0):
            return True

        return False


    @staticmethod
    def check_obstacle_between(position, action, obstacles):
        # Calculate the end position
        end_position = position + action

        # Iterate through each obstacle
        for obstacle in obstacles:
            # Check if the obstacle lies on the line segment between position
            # and end_position
            if GridData.is_point_on_line_segment(obstacle, position, end_position):
                return True

        # No obstacles found between position and end_position
        return False

    @staticmethod
    def generate_basis_vectors(dimension):

        basis_vectors = []
        for i in range(dimension):
            positive_vector = tuple(1 if j == i else 0 for j in range(dimension))
            negative_vector = tuple(-x for x in positive_vector)
            basis_vectors.extend([positive_vector, negative_vector])
        return basis_vectors

    @staticmethod
    def generate_basis_vector(dimension, index, positive=True):
        if index < 0 or index >= dimension:
            raise ValueError("Index out of range for dimension")

        vector = [0] * dimension
        vector[index] = 1 if positive else -1
        return np.array(vector)


    def generate_grid_data(self):

        d = len(self.sizes)
        ranges = [np.linspace(0, self.sizes[i], self.nums[i]) for i in range(d)]
        indices_ranges = [range(self.nums[i]) for i in range(d)]
        data = []

        for indices in product(*indices_ranges):
            args = [ranges[i][index] for i, index in enumerate(indices)]
            z = self.grid_eval(*args)
            datapoint = Data(np.array(args), z)
            data.append(datapoint)

        return data


    def grid_eval(self, x):

        action_space = GridData.generate_basis_vectors(len(self.sizes))
        dim = len(x)

        if np.random.rand() > self.noise:

            dist_to_goals = [np.sqrt(np.sum(np.array(g - np.array(x))**2)) for g in self.goals]
            closest_goal_index = np.argmin(dist_to_goals)
            closest_goal = self.goals[closest_goal_index]

            closest_coordinate = np.argmin(np.abs(x-closest_goal))

            if x[closest_coordinate] > closest_goal[closest_coordinate]:
                a = GridData.generate_basis_vector(dim, closest_coordinate, False)

            else:
                a = GridData.generate_basis_vector(dim, closest_coordinate, True)

        else:
            a = np.random.choice(action_space)
            print(f'Random choice chosen {a}')

        while GridData.check_obstacle_between(x, a, self.obstacles):
            action_space.remove(a)
            a = np.random.choice(action_space)
            print(f'Obstacle found at {x} when taking action {a}')

        return a


    def plot_grid_2D(self, bounds, ax = None, data = []):

        if len(data) == 0:
            data = GridData.generate_grid_data()
        else:
            data = data

        x_vals = [p.x for p in data]
        x_0 = [x[0] for x in x_vals]
        x_1 = [x[1] for x in x_vals]
        y_vals = [p.y for p in data]

        action_color_dict = {0:'red', 1:'blue', 2:'green', 3:'grey'}
        action_marker_dict = {0: mrk.CARETRIGHT, 1: mrk.CARETUP, 2:mrk.CARETLEFT, 3:mrk.CARETDOWN}
        plotted_markers = []
        plotted_colors = []
        color_bounds = [[-0.5,10.5],[-0.5,10.5]]

        fig, ax = plt.subplots()
        t.plot_splits_2D(ax, action_color_dict, plotted_colors=plotted_colors,
                        color_bounds=color_bounds, goals = GOALS, obstacles = OBSTACLES,
                        plot_legend=False)

        for i in range(len(x_0)):
            if action_marker_dict[y_vals[i]] not in plotted_markers:
                plt.scatter(x_0[i], x_1[i], marker = action_marker_dict[y_vals[i]],
                            label = f'Oracle action = {y_vals[i]}',
                            color = action_color_dict[y_vals[i]])
                plotted_markers.append(action_marker_dict[y_vals[i]])

            else:
                plt.scatter(x_0[i], x_1[i], marker = action_marker_dict[y_vals[i]],
                            color=action_color_dict[y_vals[i]])

class Data:

    def __init__(self, dimension, f, noise_var=0.0):
        self.dimension = dimension
        self.f = f
        self.noise_var = noise_var

    def generate_data(size, dimension, f, noise_var = 0.0):

        data = []
        for i in range(size):
            x = np.random.randn(dimension)
            y = f(x) + np.random.normal(0, noise_var)
            datapoint = Data(x,y)
            data.append(datapoint)
        return data


    def generate_assymetric_data(size, f,
                                 new_mean=10, new_sigma=2):

        data = []
        for i in range(size):
            x_1 = np.random.randn(1)
            x_new = (np.random.randn(1) + new_mean) * new_sigma
            x = list(x_1) + list(x_new)
            y = f(x)
            datapoint = Data(x,y)
            data.append(datapoint)

        return data

    def reciprocal_exp(x, lam = 1.0):
        y =  np.exp(lam * np.sum(x)) / (1 + np.exp(lam * np.sum(x)))
        if y<1/3:
            return 0
        elif y < 2/3:
            return 1
        else:
            return 2

    def floor_function(x):
        return math.floor(x) % 3

    def power_2(x, c = 2):
        return 1 - np.power(2, -np.sum(x)/c)


if __name__ == "__main__":
    SIZE = 100
    DEPTH = 3
    GOALS = [np.array([3,3])]

    data = GridData(np.array([10,10]), np.array([10,10]))

import numpy as np
from itertools import product
random.seed(10)
np.random.seed(100)

def evaluate_function(f, sizes, nums):
    d = len(sizes)
    ranges = [np.linspace(0, sizes[i], nums[i]) for i in range(d)]
    indices_ranges = [range(nums[i]) for i in range(d)]

    results = []
    for indices in product(*indices_ranges):
        args = [ranges[i][index] for i, index in enumerate(indices)]
        result = f(*args)
        results.append(result)

    return results

# Example function f
def example_function(*args):
    # Example function, replace this with your actual function
    return sum(args)

# Example usage
sizes = [1, 2, 3]  # Example sizes
nums = [3, 2, 2]   # Example nums
result = evaluate_function(example_function, sizes, nums)
print("Results:", result)

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import pandas as pd
from sklearn.tree import DecisionTreeRegressor
from collections import namedtuple
from typing_extensions import NamedTuple
import sympy
import math
import random
import statistics as stats

np.random.seed(10)
random.seed(100)

"""Design a tree based classification algorithm that takes a list of $[(x,y)]$ values and designs a decision tree with less than or greater than equal to   splits that approximates the data generation process.

Here $x \in \mathbb{R}^d, y \in \mathbb{R}/ \mathbb{N}$
"""

random.seed(10)
np.random.seed(100)
class Node:

    def __init__(self, data, initialized = False, median = 0, error = 0, dimension = 0,
                 upper_bound = None, lower_bound = None, var = None, split_range = 50,
                 int_actions=True):

        # data is a list of points of type Data

        self.data = data
        self.error = 0
        self.dimension = dimension
        self.int_actions = int_actions

        if data != []:
            self.state_dimension = len((self.data)[0].x)
            self.split_range = split_range

            if not initialized:

                best_error = np.inf
                error = 0
                self.action = round(np.median([p.y for p in data]),2)
                if int_actions:
                    self.action = int(self.action)

                for dim in range(self.state_dimension):
                    for p in data:
                        error += np.abs(p.y - self.action)
                    if error < best_error:
                        self.dimension = dim
                        self.upper_bound = np.max([p.x[dim] for p in data])
                        self.lower_bound = np.min([p.x[dim] for p in data])
                        self.var = (self.upper_bound - self.lower_bound + 1) / len(data)
                        self.median = np.median([p.x[dim] for p in data])
                        self.split_val = self.median
                        self.error = error

                l0_error = 0
                mode = stats.mode([p.y for p in data])
                for p in data:
                    l0_error += float(p.y != mode)
                self.l0error = l0_error


    def is_null_node(self):
        return len(self.data) == 0

    def calculate_split(self):

        best_dimension = 0
        best_reduction_in_error = 0
        total_error = self.error
        best_split_val = 0
        best_left_node = None
        best_right_node = None

        if (len(self.data) != 0):
            for dim in range(self.state_dimension):
                lower_bound = np.min([p.x[dim] for p in self.data])
                upper_bound = np.max([p.x[dim] for p in self.data])
                var = (upper_bound - lower_bound + 1) / len(self.data)
                split_list = np.linspace(lower_bound, upper_bound, self.split_range)

                for split_val in split_list:

                    left_data = []
                    right_data = []

                    for datapoint in self.data:
                        if (datapoint.x[dim] < split_val):
                            left_data.append(datapoint)
                        else:
                            right_data.append(datapoint)

                    if left_data != [] and right_data != []:
                        left_node = Node(left_data)
                        right_node = Node(right_data)
                        total_error = left_node.error + right_node.error
                        reduction_in_error = self.error - total_error

                        if reduction_in_error > best_reduction_in_error:
                            self.dimension = dim
                            self.split_val = split_val
                            best_reduction_in_error = reduction_in_error
                            best_split_val = split_val
                            best_left_node = left_node
                            best_right_node = right_node

            if best_left_node == None:
                print('Left node is empty')
                return Node([]), Node([])

            elif best_right_node == None:
                print('Right node is empty')
                return Node([]), Node([])

        return best_left_node, best_right_node


    def info(self):

        print('Node information is given as following:')
        print(f'{len(self.data)} is the number of data points analyzed in this dataset')
        print(f'{self.dimension} is the selected dimension for the node')
        print(f'{self.state_dimension} is the dimension of the state space')
        print(f'{self.upper_bound} is the upper bound')
        print(f'{self.lower_bound} is the lower bound')
        print(f'{self.var} is the variance')
        print(f'{self.median} is the median')

    def __str__(self):

        return f'{len(self.data)}: Number of points, all points in the {self.dimension} dimension'

random.seed(10)
np.random.seed(100)
Data = namedtuple('data', ['x', 'y'])
point = Data(np.random.randn(5), 1)
print(point.x, point.y)

'''
class GridEnv:
    def __init__(self, grid_length, agent_start, goal, transition_noise=0.1, reward_noise=0.1):
        self.grid_length = grid_length
        self.agent_start = agent_start
        self.goal = goal
        self.transition_noise = transition_noise
        self.reward_noise = reward_noise

    def reset(self):
        """Reset the environment to the initial state."""
        return self.agent_start

    def step(self, state, action):
        """Take a step in the environment based on the action."""
        # Define action mappings
        action_mapping = {0: (1, 0), 1: (0, 1), 2: (-1, 0), 3: (0, -1)}

        # Apply transition noise
        if np.random.rand() < self.transition_noise:
            action = np.random.choice(list(range(4)))

        # Move agent based on action
        delta_x, delta_y = action_mapping[action]
        new_x = max(0, min(state[0] + delta_x, self.grid_length - 1))
        new_y = max(0, min(state[1] + delta_y, self.grid_length - 1))
        new_pos = (new_x, new_y)

        # Calculate reward
        distance_to_goal = np.linalg.norm(new_pos, self.goal)
        reward = np.exp(-distance_to_goal) + np.random.normal(scale=self.reward_noise)

        return new_pos, reward

class QLearningAgent:
    def __init__(self, action_space, epsilon=0.1, alpha=0.1, gamma=0.9):
        self.action_space = action_space
        self.epsilon = epsilon
        self.alpha = alpha
        self.gamma = gamma
        self.q_table = np.zeros((grid_length, grid_length, len(action_space)))

    def choose_action(self, state):
        """Choose an action based on epsilon-greedy policy."""
        if np.random.rand() < self.epsilon:
            return np.random.choice(self.action_space)
        else:
            return np.argmax(self.q_table[state[0], state[1]])

    def update_q_table(self, state, action, reward, next_state):
        """Update Q-value table based on the Q-learning update rule."""
        max_next_q = np.max(self.q_table[next_state[0], next_state[1]])
        current_q = self.q_table[state[0], state[1], action]
        self.q_table[state[0], state[1], action] += self.alpha * (reward[0] + self.gamma * max_next_q - current_q)

if __name__ == '__main__':
    # Define environment parameters
    grid_length = 5
    agent_start = (0, 0)
    goal = (4, 4)
    action_space = [0, 1, 2, 3]

    # Create environment and agent
    env = GridEnv(grid_length, agent_start, goal)
    agent = QLearningAgent(action_space)

    # Training loop
    num_episodes = 1000
    for episode in range(num_episodes):
        state = env.reset()
        done = False
        total_reward = 0

        while not done:
            action = agent.choose_action(state)
            next_state, reward = env.step(state, action)
            agent.update_q_table(state, action, reward, next_state)
            state = next_state
            total_reward += reward
            if state == goal:
                done = True

        print(f"Episode: {episode + 1}, Total Reward: {total_reward}")

    # Extract the optimal policy from the learned Q-values
    optimal_policy = np.argmax(agent.q_table, axis=2)

    print("Optimal Policy:")
    print(optimal_policy)
'''

obstacles = [np.array([2,2]), np.array([1,1]), np.array([0,1]), np.array([0,0.5])]
check_if_obs(np.array([0,0]), obstacles, np.array([0,1]))

random.seed(10)
np.random.seed(100)
def parallel(x,y):
    #Given 2 np.arrays of size 2 x and y check if they are parallel and return
    # their ratio

    if x[0] == 0:
        if y[0] == 0:
            if x[1] != 0:
                return (True, y[1]/x[1])
            else:
                return (True, x[1]/y[1])
        else:
            return (False, 0)

    if x[1] == 0:
        if y[1] == 0:
            return (True, y[0]/x[0])
        else:
            return (False, 0)

    if y[0]/x[0] == y[1]/x[1]:
        return (True, y[0]/x[0])
    else:
        return (False, 0)

def check_if_obs(x, O, action):
    # Check if there is any element o in O from x to x+a
    for o in O:
        par, const = parallel(action+x-o, action)
        if par and const <= 1 and const > 0:
            return True

    return False

def generate_data(size, dimension, f, noise_var = 0.0):

    data = []
    for i in range(size):
        x = np.random.randn(dimension)
        y = f(x) + np.random.normal(0, noise_var)
        datapoint = Data(x,y)
        data.append(datapoint)
    return data


def generate_eval_data(dimension, bounds, number_of_points_per_dimension,
                       eval_f, noise):

    data = np.linspace(bounds[0,0], bounds[0,1],
                        num=number_of_points_per_dimension[0])

    for d in range(1, dimension):

        points = product(np.linspace(bounds[d,0], bounds[d,1],
                         num = number_of_points_per_dimension[d]), data)

    points = list(points)
    #print(points)

    data = []
    for p in points:
        #print(p)
        y = eval_f(p) + np.random.normal(scale=noise)
        datapoint = Data(p, y)
        data.append(datapoint)
    return data


def generate_grid_data(x_size, y_size,
                       num_x = None, num_y = None,
                       goals=[], noise = 0.0, obstacles = []):
    '''
    Actions are [0,1,2,3]
    0 : Right
    1 : Up~
    2: Left
    3: Down
    '''
    data = []

    if len(goals) == 0:
        goal = np.array([x_size-1, y_size-1])
    if num_x == None:
        num_x = x_size
    if num_y == None:
        num_y = y_size

    for x in np.linspace(0, x_size, num_x):
        for y in np.linspace(0, y_size, num_y):
            z = grid_eval(np.array([x,y]), x_size, y_size, goals, noise=noise)
            datapoint = Data(np.array([x,y]), z)
            data.append(datapoint)
    return data

def grid_eval(x, grid_x, grid_y, goals = [], noise = 0.0, obstacles = []):
    """

    Args:
      x:
      grid_x:
      grid_y:
      goals:
      noise:
      obstacles:

    Returns:

    """

    # obstacles are a list of np.arrays
    # [0,1,2,3] denote the list of possible actions
    # 0 is right, 1 is up, 2 is left, and 3 is down
    # goals are a list of np.arrays that denote where the goals are

    number_action_dict = {0 : np.array([1,0]), 1: np.array([0,1]),
                          2: np.array([-1,0]), 3: np.array([0,-1])}
    action_list = [0,1,2,3]

    if np.random.rand() > noise:

        dist_to_goals = [np.sum(np.array(g - np.array(x))**2) for g in goals]
        closest_goal_index = np.argmin(dist_to_goals)
        closest_goal = goals[closest_goal_index]

        if x[0] > closest_goal[0] and x[1] < closest_goal[1]:
            a = random.choice([1,2])
        elif x[0] > closest_goal[0]:
            a = 2
        elif x[1] > closest_goal[1]:
            a = 3
        elif x[0] < closest_goal[0] and x[1] < closest_goal[1]:
            a = random.choice([0,1])
        elif x[1] < closest_goal[1]:
            a = 1
        else:
            a = 0
    else:
        a = np.random.choice(action_list)
        print(f'Random choice chosen {a}')

    while check_if_obs(x, obstacles, number_action_dict[a]):
        action_list.remove(a)
        a = np.random.choice(action_list)
        print(f'Obstacle found at {x} when taking action {a}')

    return a


def generate_assymetric_data(size, f,
                             new_mean=10, new_sigma=2):

    data = []
    for i in range(size):
        x_1 = np.random.randn(1)
        x_new = (np.random.randn(1) + new_mean) * new_sigma
        x = list(x_1) + list(x_new)
        y = f(x)
        datapoint = Data(x,y)
        data.append(datapoint)

    return data

def f(x, lam = 1.0):
    y =  np.exp(lam * np.sum(x)) / (1 + np.exp(lam * np.sum(x)))
    if y<1/3:
        return 0
    elif y < 2/3:
        return 1
    else:
        return 2
def g(x):
    return math.floor(sum(x)) % 3

random.seed(10)
np.random.seed(100)
##############################################
SIZE = 100
DEPTH = 3
GOALS = [np.array([3,3])]
#DEPTH_RANGE = np.arange(3,10,2)
#depth_to_error = {}

data = generate_grid_data(10,10, goals = GOALS)
n = Node(data)
#data

random.seed(10)
np.random.seed(100)
####################
n.calculate_split()
n.info()
print(n)

random.seed(10)
np.random.seed(100)

class Tree:

    def __init__(self, head, max_depth, curr_depth=1):
        self.head = head
        self.curr_depth = curr_depth
        self.max_depth = max_depth
        if head.data != []:
            self.left = Tree(Node([]), max_depth, self.curr_depth+1)
            self.right = Tree(Node([]), max_depth, self.curr_depth+1)

    def build_tree(self):

        if self.curr_depth < self.max_depth:

            left_node, right_node = self.head.calculate_split()

            if (left_node == None) or (right_node == None):
                print(f'Tree pruned at {self.curr_depth}')
                # All NULL nodes have head to be given by Node([])
                self.left = Tree(Node([]), self.max_depth, curr_depth = self.curr_depth+1)
                self.right = Tree(Node([]), self.max_depth, curr_depth = self.curr_depth+1)
                return

            self.left = Tree(left_node, self.max_depth, self.curr_depth + 1)
            self.right = Tree(right_node, self.max_depth, self.curr_depth + 1)

            self.left.build_tree()
            self.right.build_tree()

        else:
            self.left = Tree(Node([]), self.max_depth, curr_depth = self.max_depth+1)
            self.right = Tree(Node([]), self.max_depth, curr_depth = self.max_depth+1)


    def print_tree(self):

        if len(self.head.data) != 0:
            print(f'{self.head.dimension}th dimension < {self.head.split_val}, depth {self.curr_depth}, action {self.head.action}, l1 error {self.head.error}, l0 error : {self.head.l0error}')

            if len(self.left.head.data) != 0:
                print('Left node being printed')
                self.left.print_tree()
            if len(self.right.head.data) != 0:
                print('Right node being printed')
                self.right.print_tree()

    def plot_splits(self, ax, action_color_dict,
                    color_bounds = [-5, 5], plotted_colors = [],
                    show_all_cuts = False, first_left_line = True):

        # Plot the vertical line cuts depending on whether we show all the cuts
        if show_all_cuts:
            ax.axvline(x=color_bounds[0],
                       color=(0, 0, 0),
                       linestyle='-')
            print(f'Plot line $x={color_bounds[0]}$')
        else:
            if (len(self.left.head.data) == 0) or (len(self.right.head.data) == 0) or self.curr_depth == self.max_depth:
                ax.axvline(x=color_bounds[0],
                           color=(0, 0, 0),
                           linestyle='-')
                print(f'Plot partition line $x={color_bounds[0]}$')

        # Plot the colored regions
        if (len(self.left.head.data) == 0) or (len(self.right.head.data) == 0) or (self.curr_depth == self.max_depth):
            if self.head.action not in plotted_colors:

                ax.axvspan(color_bounds[0], color_bounds[1], alpha=0.8,
                           color = action_color_dict[self.head.action],
                           label = f'Action = {self.head.action}')
                plotted_colors.append(self.head.action)
            else:
                ax.axvspan(color_bounds[0], color_bounds[1], alpha=0.8,
                        color = action_color_dict[self.head.action])

            plt.legend()
            ax.set_title('Splits of 1D space')

        else:
            (self.left).plot_splits(ax, action_color_dict,
            [color_bounds[0], self.head.split_val], plotted_colors)

            (self.right).plot_splits(ax, action_color_dict,
            [self.head.split_val, color_bounds[1]], plotted_colors)

    def plot_splits_2D(self, ax, action_color_dict,
                       color_bounds = [[-0.05,5], [-0.05,5]],
                       plotted_colors = [], prev_dim = 0,
                       obstacles = [], goals = [], obs_goals_plotted=False,
                       plot_legend=False):

        if (len(self.head.data) == 0):
            print(f'Empty node found')
            return


        if not obs_goals_plotted:
            print(obs_goals_plotted)
            plt.scatter(goals[0][0], goals[0][1], color='aqua', marker='x', label='Goal')
            for i,g in enumerate(goals[1:]):
                plt.scatter(g[0], g[1], color = 'aqua', marker='x')

            if len(obstacles) != 0:
                plt.scatter(obstacles[0][0], obstacles[0][1], color = 'saddlebrown', marker = 's', label='Obstacle')
                for i,obs in enumerate(obstacles[1:]):
                    plt.scatter(obs[0], obs[1], color = 'saddlebrown', marker='s')
            obs_goals_plotted = True

        #If we are at a last node plot the vertical/horizontal lines/regions
        if (len(self.left.head.data) == 0) or (len(self.right.head.data) == 0):
            if prev_dim == 0:
                print(f'Plot partition line $x_{prev_dim} = {color_bounds[0][0]}$')
                ax.plot([color_bounds[0][0], color_bounds[0][0]], color_bounds[1], color=(0,0,0), linestyle='-')

                if self.head.action not in plotted_colors:

                    ax.fill_between(color_bounds[0], min(color_bounds[1]),
                                    max(color_bounds[1]), label = f'Int. action={self.head.action}',
                                    alpha=0.5, color = action_color_dict[self.head.action])

                    plotted_colors.append(self.head.action)
                    print(f'We color the vertical region from {color_bounds[0][0]} to {color_bounds[0][1]} from ymin={color_bounds[1][0]} to ymax = {color_bounds[1][1]} with {self.head.action} color')
                else:
                    ax.fill_between(color_bounds[0], min(color_bounds[1]),
                                    max(color_bounds[1]),
                                    alpha=0.5, color = action_color_dict[self.head.action])
                    print(f'We color the vertical region from {color_bounds[0][0]} to {color_bounds[0][1]} from ymin={color_bounds[1][0]} to ymax = {color_bounds[1][1]} with {self.head.action} color')

            elif prev_dim == 1:
                print(f'Plot partition line  x_{self.head.dimension} = {color_bounds[1][0]}')
                ax.plot(color_bounds[0], [color_bounds[1][0], color_bounds[1][0]], color=(0,0,0), linestyle='-')

                if self.head.action not in plotted_colors:
                    ax.fill_between(color_bounds[0], min(color_bounds[1]),
                                    max(color_bounds[1]), label = f'Int. action={self.head.action}',
                                    alpha=0.5, color = action_color_dict[self.head.action])

                    plotted_colors.append(self.head.action)
                    print(f'We color the horizontal region from {color_bounds[1][0]} to {color_bounds[1][1]} from xmin={color_bounds[0][0]} to xmax = {color_bounds[0][1]} with {self.head.action} color')
                else:
                    ax.fill_between(color_bounds[0], min(color_bounds[1]),
                                    max(color_bounds[1]), label = f'Int. action={self.head.action}',
                                    alpha=0.5, color = action_color_dict[self.head.action])
                    print(f'We color the horizontal region from {color_bounds[1][0]} to {color_bounds[1][1]} from xmin={color_bounds[0][0]} to xmax = {color_bounds[0][1]} with {self.head.action} color')

            if plot_legend:
                plt.legend()
            ax.set_title('Splits of the 2D space')

        # If we are not at the last node, decide further splits
        elif self.head.dimension == 0:
            (self.left).plot_splits_2D(ax, action_color_dict,
                                       [[color_bounds[0][0], self.head.split_val],
                                       [color_bounds[1][0], color_bounds[1][1]]],
                                       plotted_colors, prev_dim = 0, obstacles = obstacles,
                                       goals = goals, obs_goals_plotted=obs_goals_plotted,
                                       plot_legend=plot_legend)

            (self.right).plot_splits_2D(ax, action_color_dict,
                                        [[self.head.split_val, color_bounds[0][1]],
                                        [color_bounds[1][0], color_bounds[1][1]]],
                                        plotted_colors, prev_dim = 0, obstacles = obstacles,
                                        goals = goals, obs_goals_plotted = obs_goals_plotted,
                                        plot_legend=plot_legend)

        elif self.head.dimension == 1:

            (self.left).plot_splits_2D(ax, action_color_dict,
                                      [[color_bounds[0][0], color_bounds[0][1]],
                                      [color_bounds[1][0], self.head.split_val]],
                                      plotted_colors, prev_dim =1, obstacles=obstacles,
                                      goals=goals, obs_goals_plotted = obs_goals_plotted,
                                      plot_legend = plot_legend)

            (self.right).plot_splits_2D(ax, action_color_dict,
                                        [[color_bounds[0][0], color_bounds[0][1]],
                                        [self.head.split_val, color_bounds[1][1]]],
                                        plotted_colors, prev_dim =1, obstacles=obstacles,
                                        goals=goals, obs_goals_plotted=obs_goals_plotted,
                                        plot_legend=plot_legend)


    def plot_tree(self, x, y, step_x, step_y, bounds = [-3, 3]):

        # Plot current node
        if len(self.head.data) != 0:

            first_bound = f"{round(bounds[0],2)} < $x_0$ < {round(bounds[0],2)}"
            action = f"\nAction = {self.head.action}"
            text = first_bound + action

            plt.text(x, y, text,
                    ha='center', va='center', bbox=dict(facecolor='lightblue', alpha=0.5, edgecolor='black', pad=0),
                    fontsize=8, fontweight='bold', style='italic', fontfamily='serif')

            plt.plot([x, x-step_x], [y, y-step_y], 'b-', linewidth=1)  # Arrow towards left child
            plt.plot([x, x+step_x], [y, y-step_y], 'b-', linewidth=1)  # Arrow towards right child

        # Plot left child
            self.left.plot_tree(x - step_x, y - step_y, step_x/2, step_y, [bounds[0], round(self.head.split_val,2)])

        # Plot right child
            self.right.plot_tree(x + step_x, y - step_y, step_x/2, step_y, [round(self.head.split_val,2), bounds[1]])


    def plot_tree_2D(self, x, y, step_x, step_y, bounds = [[-3, 3],[-3, 3]]):

        # Plot current node
        if len(self.head.data) == 0:
            print('Zero node found!')
        else:
            first_bound = f"{round(bounds[0][0],2)} < $x_0$ < {round(bounds[0][1],2)}"
            next_bound = f"\n{round(bounds[1][0],2)} < $x_1$ < {round(bounds[1][1],2)}"
            action = f"\nAction = {self.head.action}"
            text = first_bound + next_bound + action

            plt.text(x, y, text,
                     ha='center', va='center', bbox=dict(facecolor='lightblue', alpha=0.5, edgecolor='black', pad=0),
                     fontsize=8, fontweight='bold', style='italic', fontfamily='serif')

            plt.plot([x, x-step_x], [y, y-step_y], 'b-', linewidth=1)  # Arrow towards left child
            plt.plot([x, x+step_x], [y, y-step_y], 'b-', linewidth=1)  # Arrow towards right child

        if len(self.left.head.data) != 0 and len(self.right.head.data) != 0:
            if self.head.dimension == 0:

                self.left.plot_tree_2D(x-step_x, y-step_y, step_x/2, step_y,
                                    [[bounds[0][0], round(self.head.split_val,2)], bounds[1]])

                self.right.plot_tree_2D(x+step_x, y-step_y, step_x/2, step_y,
                                    [[round(self.head.split_val,2), bounds[0][1]], bounds[1]])
            elif self.head.dimension == 1:

                self.left.plot_tree_2D(x-step_x, y-step_y, step_x/2, step_y,
                                    [bounds[0],[bounds[1][0], round(self.head.split_val,2)]])

                self.right.plot_tree_2D(x+step_x, y-step_y, step_x/2, step_y,
                                    [bounds[0], [round(self.head.split_val,2), bounds[1][1]]])

    def calculate_approximation_error(self):

        if len(self.left.head.data) == 0 or len(self.right.head.data) == 0:
            #print(self.head.error)
            return self.head.error
        else:
            return self.left.calculate_approximation_error() + self.right.calculate_approximation_error()

"""To Do:

*   Work on 2D/ND versions of this
"""

random.seed(10)
np.random.seed(100)

def generate_random_data(size, dimension, f, noise_var = 0.0, data_var = 1.0):

    data = []
    for i in range(size):
        x = np.random.randn(dimension) * data_var
        y = f(x) + np.random.normal(0.0,noise_var)
        datapoint = Data(x,y)
        data.append(datapoint)
    return data

def f(x, lam = 1.0):
    y = np.exp(lam * np.sum(x)) / (1 + np.exp(lam * np.sum(x)))
    if y < 1/3:
        return 0
    if y<2/3:
        return 1
    else:
        return 2


def g(x):
    return math.floor(np.sum(x) % 3)

def h(x, c = 2):
    return 1 - np.power(2, -np.sum(x)/c)

random.seed(10)
np.random.seed(100)

SIZE = 1000
DIMENSIONS = 10
DEPTH = 4
data = generate_data(SIZE, DIMENSIONS, f, 2.0)
n = Node(data, 0)
t = Tree(n, DEPTH)
t.build_tree()
t.print_tree()

generate_eval_data(2, np.array([[0,10], [0,10]]), np.array([3,4]),
                   f, noise = 1.0)

random.seed(10)
np.random.seed(100)

SIZE = 1000
DIMENSIONS = 1
DEPTH = 5
DEPTH_RANGE = np.arange(3,10,2)
depth_to_error = {}
GOALS = [np.array([1,1]), np.array([3,4]), np.array([6,7])]
#OBSTACLES = [(2,0), (3,1), (2,3)]

data = generate_grid_data(10,10, goals = GOALS, num_x = 10, num_y = 10, noise = 0.0)
n = Node(data, 0)
t = Tree(n, DEPTH)
t.build_tree()
print(t.calculate_approximation_error())

t.print_tree()

random.seed(10)
np.random.seed(100)

import matplotlib.markers as mrk

noises = [0.2, 0.4, 0.6]

x_vals = [p.x for p in data]
x_0 = [x[0] for x in x_vals]
x_1 = [x[1] for x in x_vals]
y_vals = [p.y for p in data]

action_color_dict = {0:'red', 1:'blue', 2:'green', 3:'grey'}
action_marker_dict = {0: mrk.CARETRIGHT, 1: mrk.CARETUP, 2:mrk.CARETLEFT, 3:mrk.CARETDOWN}
plotted_markers = []
plotted_colors = []
color_bounds = [[-0.5,10.5],[-0.5,10.5]]

fig, ax = plt.subplots()
t.plot_splits_2D(ax, action_color_dict, plotted_colors=plotted_colors,
                 color_bounds=color_bounds, goals = GOALS,
                 plot_legend=False)

for i in range(len(x_0)):
    if action_marker_dict[y_vals[i]] not in plotted_markers:
        plt.scatter(x_0[i], x_1[i], marker = action_marker_dict[y_vals[i]],
                    label = f'Oracle action = {y_vals[i]}',
                    color = action_color_dict[y_vals[i]])
        plotted_markers.append(action_marker_dict[y_vals[i]])

    else:
        plt.scatter(x_0[i], x_1[i], marker = action_marker_dict[y_vals[i]],
                    color=action_color_dict[y_vals[i]])


#plt.legend()

t.print_tree()

t.plot_tree_2D(0, 1, 2, 1.5, bounds = color_bounds)

import graphviz

# number_action_dict = {0 : np.array([1,0]), 1: np.array([0,1]),
#                       2: np.array([-1,0]), 3: np.array([0,-1])}

dot_code = """
digraph BinaryTree {
    node [shape=rectangle, style=filled, fillcolor=lightblue, fontcolor=black]

    1 [label=" X_0 < 2.63 \n L1 Error = 116.0 \n L0 Error = 54.0 \n Action = Left"]

    2 [label=" X_1 < 3.68 \n L1 Error = 30.0 \n L0 Error = 9.0 \n Action = Down"]

    3 [label=" X_1 < 5.0 \n L1 Error = 62.0 \n L0 Error = 29.0 \n Action = Down"]

    4 [label=" X_0 < 0.117 \n L1 Error = 18.0 \n L0 Error = 7.0 \n Action = Left"]

    5 [label=" X_1 < 7.22 \n  L1 Error = 0 \n L0 Error = 0 \n Action = Down"]

    6 [label=" X_1 < 0.175 \n L1 Error = 6.0 \n L0 Error = 1.0 \n Action = Down"]
    7 [label=" X_1 < 2.28 \n L1 Error = 8.0 \n L0 Error = 3.0 \n Action = Down"]
    8 [label=" X_1 < 0.0 \n L1 Error = 0.0 \n L0 Error = 0.0 \n Action = Up"]
    9 [label=" X_1 < 2.22 \n L1 Error = 0.0 \n L0 Error = 0.0 \n Action = Down"]
    10 [label=" X_1 < 1.11 \n L1 Error = 2.0 \n L0 Error = 1.0 \n Action = Down"]
    11 [label=" X_1 < 3.33 \n L1 Error = 2.0 \n L0 Error = 1.0 \n Action = Up"]

    1 -> 2
    1 -> 3
    2 -> 4
    2 -> 5
    4 -> 6
    4 -> 7
    6 -> 8
    6 -> 9
    7 -> 10
    7 -> 11
}
"""

graph = graphviz.Source(dot_code)
graph.render('binary_tree', format='png', cleanup=True)

def h(x):
    z = np.sum(x)
    y = (np.exp(z) - np.exp(-z)) / (np.exp(z) + np.exp(-z))
    if y < 0:
        return 0
    elif y < 2:
        return 1
    else:
        return 2

def plot_with_confidence_intervals(ax, xs, means, variances,
                                   xlabel='Xs', ylabel='Means',
                                   label='means', color = 'blue'):
    # Create line plot between xs and means
    ax.plot(xs, means, label=label, color = color)

    # Create scatter plot with error bars representing confidence intervals
    ax.errorbar(xs, means, yerr=variances, fmt='o', markersize=5, color = color)

    # Add labels and legend
    ax.set_xlabel(xlabel)
    ax.set_ylabel(ylabel)
    plt.legend()

random.seed(10)
np.random.seed(100)

datas = generate_data(100, 2, h, noise_var = 0.0)
DEPTH_RANGE = [2,3,4]
depth_errors = []
depth_var = []

for depth_no, depth in enumerate(DEPTH_RANGE):
    errors_trials = []
    n = Node(datas, 0)
    t = Tree(n, depth)
    print('d is', depth)
    t.build_tree()
    print(f'for d={depth}, error is {t.calculate_approximation_error()}')


print(errors_trials)

errors_trials

random.seed(10)
np.random.seed(100)

#error_vs_depth plots
TRIALS = 20
DEPTH_RANGE = np.arange(2,6,1)
colors = ['blue', 'green', 'red']
policies = [f,g,h]
policy_names = ['f', 'g', 'h']

fig, ax = plt.subplots()

for policy_no, policy in enumerate(policies):
    depth_errors = []
    depth_var = []
    datas = generate_data(100, 2, policy, noise_var = 0.1)
    for depth_no, depth in enumerate(DEPTH_RANGE):
        errors_trials = []
        var_trials = []
        for t in range(TRIALS):
            n = Node(datas, 0)
            t = Tree(n, depth)
            t.build_tree()
            errors_trials.append(t.calculate_approximation_error())

        avg_trial_error = np.mean(np.array(errors_trials))
        var_trials = np.var(np.array(errors_trials))

        depth_errors.append(avg_trial_error)
        depth_var.append(var_trials)

    plot_with_confidence_intervals(ax, DEPTH_RANGE, depth_errors,
                                   depth_var, xlabel='Depth', ylabel='Error',
                                   label=f'policy name = {policy_names[policy_no]}', color = colors[policy_no])

plt.title('Error vs depth for different policies')
plt.xlabel('Depth')
plt.ylabel('Total Error')
plt.legend()

random.seed(10)
np.random.seed(100)
#########################################################
TRIALS = 10
DEPTH_RANGE = np.arange(2,6,1)
NOISES = [0.0, 0.5, 1.0, 1.5, 2.0]
colors = ['blue', 'green', 'red', 'pink', 'brown', 'teal']
#avg_errors_noise
fig, ax = plt.subplots()
noise_errors_depth = []
noise_var_depth = []

for i,noise in enumerate(NOISES):
    avg_errors_depth = []
    var_errors_depth = []
    data = data = generate_grid_data(10,10, goals = GOALS, num_x = 10,
                                     num_y = 10, noise = 0.0)
    for depth in DEPTH_RANGE:
        errors_trial = []
        for t in range(TRIALS):
            n = Node(data, 0)
            t = Tree(n, DEPTH)
            t.build_tree()
            errors_trial.append(t.calculate_approximation_error())

        avg_trial_error = np.mean(np.array(errors_trial))
        var_trials = np.var(np.array(errors_trial))

        avg_errors_depth.append(avg_trial_error)
        var_errors_depth.append(var_trials)

    plot_with_confidence_intervals(ax, DEPTH_RANGE, avg_errors_depth,
                                   var_errors_depth, xlabel='Depth', ylabel='Error',
                                   label=f'Noise={noise}', color = colors[i])
    noise_errors_depth.append(avg_errors_depth)
    noise_var_depth.append(var_errors_depth)

plt.title('Depth vs errors for different levels of noise in the reward')
plt.xlabel('Depth')
plt.ylabel('Total Error')
plt.legend()

random.seed(10)
np.random.seed(100)
#############################
SIZE_RANGE = [10, 20, 30, 40]
TRIALS = 50
DEPTH_RANGE = np.arange(2,6,1)
DIMENSION = 2
BOUNDS = np.array([[0,10],[0,10]])
colors = ['blue', 'green', 'red', 'pink', 'brown', 'teal']
#avg_errors_noise
fig, ax = plt.subplots()
sizeerrors = []
sizevars = []

for i,size in enumerate(SIZE_RANGE):
    avg_errors_depth = []
    var_errors_depth = []
    no_points_per_dim = np.array([size] * DIMENSION)
    for DEPTH in DEPTH_RANGE:
        errors_trial = []
        for t in range(TRIALS):
            data = generate_eval_data(DIMENSION, BOUNDS, no_points_per_dim,
                                      g, noise = 0.0)
            #print(data)
            n = Node(data, 0)
            t = Tree(n, DEPTH)
            t.build_tree()
            errors_trial.append(t.calculate_approximation_error())

        avg_trial_error = np.mean(np.array(errors_trial))
        var_trials = np.var(np.array(errors_trial))/2
        avg_errors_depth.append(avg_trial_error)
        var_errors_depth.append(var_trials)

    sizeerrors.append(avg_errors_depth)
    sizevars.append(var_errors_depth)
    plot_with_confidence_intervals(ax, SIZE_RANGE, avg_errors_depth,
                                   var_errors_depth, xlabel='Depth', ylabel='Error',
                                   label=f'Size = {size}', color = colors[i])

plt.title('Error vs depth for different sizes')
plt.xlabel('Depth')
plt.ylabel('Total Error')
plt.legend()

noise_var_depth

sizevars

sizeerrors

SIZE_RANGE

random.seed(10)
np.random.seed(100)
################################################################################
SIZE = 20
TRIALS = 500
DEPTH_RANGE = np.arange(2,6,1)
DIMENSIONS = [5, 10, 15, 20, 25]
colors = ['blue', 'green', 'red', 'pink', 'brown', 'teal']
#avg_errors_noise
dim_errors = []
dim_vars = []
fig, ax = plt.subplots()

for i,dim in enumerate(DIMENSIONS):
    avg_errors_depth = []
    var_errors_depth = []
    for DEPTH in DEPTH_RANGE:
        errors_trial = []
        bounds = np.array([[0, 10] for d in range(dim)])
        points_per_dim = np.array([SIZE] * dim)
        for t in range(TRIALS):
            data = generate_eval_data(dim, bounds, points_per_dim, g, noise = 0.0)
            n = Node(data, 0)
            t = Tree(n, DEPTH)
            t.build_tree()
            errors_trial.append(t.calculate_approximation_error())

        avg_trial_error = np.mean(np.array(errors_trial))
        var_trials = np.var(np.array(errors_trial))

        avg_errors_depth.append(avg_trial_error)
        var_errors_depth.append(var_trials)

    plot_with_confidence_intervals(ax, DEPTH_RANGE, avg_errors_depth,
                                   var_errors_depth, xlabel='Depth', ylabel='Error',
                                   label=f'Dimension={dim}', color = colors[i])
    dim_errors.append(avg_errors_depth)
    dim_vars.append(var_errors_depth)

plt.title('Error vs depth for different dimensions')
plt.xlabel('Depth')
plt.ylabel('Total Error')
plt.legend()

np.save('dim_errors_l1.npy', dim_errors)
np.save('var_errors_l1.npy', dim_vars)

dim = 2
SIZE = 20
TRIALS = 500
DEPTH_RANGE = np.arange(2,6,1)
DIMENSIONS = [5, 10, 15, 20, 25]
for dim in DIMENSIONS:
    data = generate_eval_data(dim, bounds, points_per_dim, g, noise = 0.0)
    n = Node(data, 0)
    t = Tree(n, DEPTH)
    t.build_tree()
    t.print_tree()

'''
# Create a figure and two subplots side by side
fig, axs = plt.subplots(1, 2, figsize=(10, 5))

l1_errors = np.load('dim_errors_l1.npy')
l1_vars = np.load('var_errors_l1.npy')

#l2_errors = np.load('dim_errors_l2.npy')
#l2_vars = np.load('var_errors_l2.npy')

for i, dim in enumerate(DIMENSIONS):
    plot_with_confidence_intervals(axs[0], DEPTH_RANGE, l1_errors[i],
                                    l1_vars[i]*2, xlabel='Depth', ylabel='Error',
                                    label=f'Dimension={dim}', color = colors[i])
axs[0].set_title('Error L1 norm')
axs[0].set_xlabel('Depth')
axs[0].set_ylabel('Total Error')
plt.legend()



for i, dim in enumerate(DIMENSIONS):
    plot_with_confidence_intervals(axs[1], DEPTH_RANGE, l2_errors[i],
                                    l2_vars[i]*3, xlabel='Depth', ylabel='Error',
                                    label=f'Dimension={dim}', color = colors[i])
axs[1].set_title('Error L2 norm')
axs[1].set_xlabel('Depth')
axs[1].set_ylabel('Total Error')

plt.legend()
fig.suptitle('Error vs depth for different dimensions and metrics')
plt.show()
'''

data = generate_data(100, 2, f)
n = Node(data, 0)
t = Tree(n, DEPTH)
t.build_tree()

import matplotlib.markers as mrk

x_vals = [p.x for p in data]
x_0 = [x[0] for x in x_vals]
x_1 = [x[1] for x in x_vals]
y_vals = [p.y for p in data]

action_color_dict = {0:'red', 1:'blue', 2:'green', 3:'grey'}
action_marker_dict = {0: mrk.CARETRIGHT, 1: mrk.CARETUP, 2:mrk.CARETLEFT, 3:mrk.CARETDOWN}
plotted_markers = []
plotted_colors = []
color_bounds = [[-0.5,6],[-0.5,6]]

fig, ax = plt.subplots()
t.plot_splits_2D(ax, action_color_dict, plotted_colors=plotted_colors,
                 color_bounds=color_bounds)

for i in range(len(x_0)):
    if action_marker_dict[y_vals[i]] not in plotted_markers:
        plt.scatter(x_0[i], x_1[i], marker = action_marker_dict[y_vals[i]],
                    label = f'Action = {y_vals[i]}',
                    color = action_color_dict[y_vals[i]])
        plotted_markers.append(action_marker_dict[y_vals[i]])

    else:
        plt.scatter(x_0[i], x_1[i], marker = action_marker_dict[y_vals[i]],
                    color=action_color_dict[y_vals[i]])

plt.legend()

SIZE = 100
DIMENSIONS = 1
DEPTH = 3
DEPTH_RANGE = np.arange(3,10,2)
depth_to_error = {}

data = generate_data(SIZE, DIMENSIONS, g)
n = Node(data, 0)

for d in range(3,10,2):
    t = Tree(n,d)
    t.build_tree()
    depth_to_error[d] = t.calculate_approximation_error()

plt.plot(DEPTH_RANGE, [depth_to_error[d] for d in DEPTH_RANGE])
plt.title('Error vs depth')
plt.xlabel('Depth of tree')
plt.ylabel('Error')
plt.show()

import numpy as np

class BloodGlucoseEnvironment:
    def __init__(self, num_states=30, actions=[0, 1, 2], discount_factor=0.8):
        self.num_states = num_states
        self.actions = actions
        self.discount_factor = discount_factor
        self.T = self._compute_transition_probabilities()
        self.R = self._compute_rewards()

    def _compute_transition_probabilities(self):
        T = np.zeros((self.num_states, len(self.actions), self.num_states))
        for s in range(self.num_states):
            for a in self.actions:
                if a == 0:
                    for t in range(min(s + 10, self.num_states)):
                        T[s, a, t] = 0.7 / min(s + 10, self.num_states)
                    for t in range(s + 1):
                        T[s, a, t] += 0.3 / (s + 1)
                elif a == 1:
                    for t in range(min(s + 5, self.num_states)):
                        T[s, a, t] = 0.3 / min(s + 5, self.num_states)
                    for t in range(s + 1):
                        T[s, a, t] += 0.7 / (s + 1)
                elif a == 2:
                    for t in range(s + 1):
                        T[s, a, t] = 1.0 / (s + 1)
        return T

    def _compute_rewards(self):
        R = np.zeros((self.num_states, len(self.actions), self.num_states))
        for s in range(self.num_states):
            for a in self.actions:
                for t in range(self.num_states):
                    R[s, a, t] = 1.5 / (abs((s / 29) - (a / 2)) + 1) + np.abs(s/29 - a/2)/20
        return R

    def step(self, state, action):
        next_state = np.random.choice(self.num_states, p=self.T[state, action])
        reward = self.R[state, action, next_state]
        return next_state, reward

    def get_transition_probabilities(self):
        return self.T

    def get_rewards(self):
        return self.R

def policy_iteration(env, num_iterations=20000):
    policy = np.zeros(env.num_states, dtype=int)  # Initialize policy arbitrarily
    V = np.zeros(env.num_states)  # Initialize value function
    gamma = env.discount_factor

    for _ in range(num_iterations):
        # Policy evaluation
        for s in range(env.num_states):
            action = policy[s]
            next_state, reward = env.step(s, action)
            V[s] = reward + gamma * V[next_state]

        # Policy improvement
        new_policy = np.zeros(env.num_states, dtype=int)
        for s in range(env.num_states):
            best_action = None
            best_value = float('-inf')
            for a in env.actions:
                next_state, reward = env.step(s, a)
                value = reward + gamma * V[next_state]
                if value > best_value:
                    best_value = value
                    best_action = a
            new_policy[s] = best_action
        if np.array_equal(new_policy, policy):
            break
        policy = new_policy

    return policy, V

# Create the environment
env = BloodGlucoseEnvironment()

# Find the optimal policy
optimal_policy, optimal_values = policy_iteration(env)

print("Optimal Policy:")
print(optimal_policy)
print("Optimal Values:")
print(optimal_values)

def make_list_into_function(l):

    def functor(num):

        if (num >= len(l)) or (num < 0):
            return 0
        else:
            return l[num]

    return functor


optimal_function = make_list_into_function(optimal_policy)

data =  [Data(np.array([i]), y) for i,y in enumerate(optimal_policy)]
n = Node(data, 0, split_range=5)
t = Tree(n, DEPTH)
t.build_tree()
print(t.print_tree())

x_vals = [p.x for p in data]
y_vals = [p.y for p in data]
action_color_dict = {0:'red', 1:'blue', 2:'green'}

fig, ax = plt.subplots()
t.plot_splits(ax, action_color_dict, color_bounds=[-1,31], plotted_colors = [])
ax.scatter(x_vals, y_vals, marker = '*',color='black')

red_patch = mpatches.Patch(color='red', label='None')
blue_patch = mpatches.Patch(color='blue', label='Bolus')
green_patch = mpatches.Patch(color='green', label='Bolus+Basal')

ax.legend(handles=[red_patch, blue_patch, green_patch])

t.plot_tree(0, 1, 2, 1.5, bounds = [-1,31])

split_ranges = [5, 10, 15, 20, 25, 30]
#split_to_color = {5:'red', 1}

for s in split_ranges:

    n = Node(data, 0, s)
    for d in range(2,8):
        t = Tree(n,d)
        t.build_tree()
        depth_to_error[d] = t.calculate_approximation_error()

    plt.plot(range(2,8), [depth_to_error[d] for d in range(2,8)], label = f'Split value: {s}')

plt.title('Error vs depth')
plt.xlabel('Depth of tree')
plt.ylabel('Error')
plt.legend()
plt.show()

!pip install swig
!pip install gym[box2d]

# @title Update/Upgrade the system and install libs
!apt-get update > /dev/null 2>&1
!apt-get install -y xvfb python-opengl ffmpeg > /dev/null 2>&1
!apt-get install -y swig build-essential python-dev python3-dev > /dev/null 2>&1
!apt-get install x11-utils > /dev/null 2>&1
!apt-get install xvfb > /dev/null 2>&1

# @title Install dependencies
!pip install rarfile --quiet
!pip install stable-baselines3[extra] --quiet
!pip install ale-py --quiet
!pip install gym[box2d] --quiet
!pip install pyvirtualdisplay --quiet
!pip install pyglet --quiet
!pip install pygame --quiet
!pip install minigrid --quiet
!pip install -q swig --quiet
!pip install -q gymnasium[box2d] --quiet
!pip install 'minigrid<=2.1.1' --quiet
!pip3 install box2d-py --quiet
!pip install gymnasium

# Imports
import io
import os
import glob
#import torch
import base64

import numpy as np
import matplotlib.pyplot as plt

import sys
import gymnasium as gym
sys.modules["gym"] = gym


from gym import spaces
from gym.envs.box2d.lunar_lander import *
from gym.wrappers.monitoring.video_recorder import VideoRecorder

env = gym.make('LunarLander-v2')
state = env.reset()
print(state)

def optimal_action(state):
    # Extract relevant information from the state
    x, y, vx, vy, angle, v_angle, _, _ = state

    # Define constants
    GRAVITY = -1  # Assume downward acceleration due to gravity
    PAD_Y = 0.0   # Y-coordinate of the landing pad (updated to 0)

    # Compute vertical direction
    vertical_direction = 'up' if y > PAD_Y else 'down'

    # Compute horizontal direction
    horizontal_direction = 'left' if x < 0 else 'right'

    # Compute optimal actions based on current state and direction
    if vertical_direction == 'up':
        if vy > 0:
            # If ascending, continue ascending or stabilize horizontal orientation
            return 2  # Fire main engine
        elif abs(x) < 0.05:  # Close to the center, stabilize horizontal orientation
            return 0  # Do nothing
        elif x < 0:
            return 3  # Fire right orientation engine
        else:
            return 1  # Fire left orientation engine
    else:  # Vertical direction is down
        if vy < 0:
            # If descending, continue descending or stabilize horizontal orientation
            return 2  # Fire main engine
        elif abs(x) < 0.05:  # Close to the center, stabilize horizontal orientation
            return 0  # Do nothing
        elif x < 0:
            return 1  # Fire left orientation engine
        else:
            return 3  # Fire right orientation engine

# Example usage:
# Given the current state, call optimal_action function to get the recommended action
# state = env.reset()  # Get initial state from the environment
# action = optimal_action(state)
# print("Recommended action:", action)

# @title Play Video function
from IPython.display import HTML
from base64 import b64encode
from pyvirtualdisplay import Display
import os

# create the directory to store the video(s)
os.makedirs("./video", exist_ok=True)

display = Display(visible=False, size=(1400, 900))
_ = display.start()

"""
Utility functions to enable video recording of gym environment
and displaying it.
To enable video, just do "env = wrap_env(env)""
"""
def render_mp4(videopath: str) -> str:
  """
  Gets a string containing a b4-encoded version of the MP4 video
  at the specified path.
  """
  mp4 = open(videopath, 'rb').read()
  base64_encoded_mp4 = b64encode(mp4).decode()
  return f'<video width=400 controls><source src="data:video/mp4;' \
         f'base64,{base64_encoded_mp4}" type="video/mp4"></video>'

env_name = 'LunarLander-v2'
env = gym.make(env_name)
print('State shape: ', env.observation_space.shape)
print('Number of actions: ', env.action_space.n)

import gym
import numpy as np

# Create Lunar Lander environment
env = gym.make('LunarLander-v2', render_mode = 'rgb_array')
vid = VideoRecorder(env, path=f"video/{env_name}_pretraining.mp4")
# Reset environment to get initial state
observation = env.reset()[0]

total_reward = 0
done = False
while not done:
  frame = env.render()
  vid.capture_frame()
  action = optimal_action(observation)
  observation, reward, done, info, _ = env.step(action)
  total_reward += reward
vid.close()
env.close()
print(f"\nTotal reward: {total_reward}")

# show video
html = render_mp4(f"video/{env_name}_pretraining.mp4")
HTML(html)

